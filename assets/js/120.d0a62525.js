(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{595:function(v,t,_){"use strict";_.r(t);var a=_(10),s=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"ps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ps"}},[v._v("#")]),v._v(" ps")]),v._v(" "),t("p",[t("code",[v._v("ps")]),v._v("命令用于显示当前系统的进程状态。")]),v._v(" "),t("ul",[t("li",[t("p",[t("code",[v._v("ps -ef")]),v._v(" 显示所有进程")])]),v._v(" "),t("li",[t("p",[t("code",[v._v("ps -aux")]),v._v(" 显示所有进程")])]),v._v(" "),t("li",[t("p",[t("code",[v._v("ps -eo pid,%mem,rss,command")]),v._v(" 显示进程ID、内存使用率、实际内存使用量、命令")])])]),v._v(" "),t("h2",{attrs:{id:"top"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#top"}},[v._v("#")]),v._v(" TOP")]),v._v(" "),t("p",[v._v("能够实时显示系统中各个进程的资源占用状况.")]),v._v(" "),t("p",[v._v("输入"),t("code",[v._v("P")]),v._v("按cpu使用率排序，"),t("code",[v._v("M")]),v._v("按内存使用率排序,输入'R'反转排序。")]),v._v(" "),t("h3",{attrs:{id:"load-average"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#load-average"}},[v._v("#")]),v._v(" load average")]),v._v(" "),t("p",[v._v("load average有三个值，分别表示1分钟、5分钟、15分钟的负载情况，大于核心数时，表示系统负载过高。")]),v._v(" "),t("p",[v._v("平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，即R+D状态的进程数量。代表的是当前系统对cpu的负担情况，平均负载要结合当前系统所拥有的cpu个数来看 ，理想情况下：平均负载等于CPU个数")]),v._v(" "),t("h4",{attrs:{id:"负载过高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载过高"}},[v._v("#")]),v._v(" 负载过高")]),v._v(" "),t("p",[v._v("说明进程占用CPU时间过多，或者进程等待CPU时间过多，造成进程任务排队。")]),v._v(" "),t("p",[v._v("shift +t可以按照 CPU TIME 进行排序。找到对应进程ID。")]),v._v(" "),t("h3",{attrs:{id:"cpu使用率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu使用率"}},[v._v("#")]),v._v(" CPU使用率")]),v._v(" "),t("p",[v._v("CPU使用率 = CPU时间片被程序使用的时间 / 总时间")]),v._v(" "),t("h4",{attrs:{id:"cpu使用率过高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu使用率过高"}},[v._v("#")]),v._v(" CPU使用率过高")]),v._v(" "),t("p",[v._v("可能是程序运行出错，出现了死循环。输入"),t("code",[v._v("P")]),v._v("按cpu使用率排序，找到使用率最高的进程ID。")]),v._v(" "),t("h3",{attrs:{id:"查看单个进程的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看单个进程的情况"}},[v._v("#")]),v._v(" 查看单个进程的情况")]),v._v(" "),t("p",[t("code",[v._v("top -Hp pid")]),v._v("命令查看各个线程的情况。对应线程ID是十进制。")]),v._v(" "),t("h2",{attrs:{id:"vmstat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vmstat"}},[v._v("#")]),v._v(" vmstat")]),v._v(" "),t("p",[v._v("实时显示系统的虚拟内存、进程、CPU等信息。一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数。")]),v._v(" "),t("p",[v._v("r 表示运行队列(就是说多少个进程真的分配到CPU)，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。")]),v._v(" "),t("p",[v._v("b 表示阻塞的进程。")]),v._v(" "),t("p",[v._v("swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。")]),v._v(" "),t("p",[v._v("free   空闲的物理内存的大小。")]),v._v(" "),t("p",[v._v("si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。")]),v._v(" "),t("p",[v._v("so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。")]),v._v(" "),t("p",[v._v("in 每秒CPU的中断次数，包括时间中断")]),v._v(" "),t("p",[v._v("cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。")]),v._v(" "),t("p",[v._v("us 用户CPU时间。")]),v._v(" "),t("p",[v._v("sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。")]),v._v(" "),t("p",[v._v("id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。")]),v._v(" "),t("p",[v._v("wt 等待IO CPU时间。")]),v._v(" "),t("h2",{attrs:{id:"lsof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lsof"}},[v._v("#")]),v._v(" lsof")]),v._v(" "),t("p",[t("code",[v._v("lsof(list open files)")]),v._v("是一个列出当前系统打开文件的工具。")]),v._v(" "),t("p",[v._v("lsof 查看端口占用语法格式："),t("code",[v._v("lsof -i:端口号")])]),v._v(" "),t("h2",{attrs:{id:"netstat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netstat"}},[v._v("#")]),v._v(" netstat")]),v._v(" "),t("p",[t("code",[v._v("netstat -tunlp")]),v._v(" 用于显示 tcp，udp 的端口和进程等相关情况。")]),v._v(" "),t("p",[v._v("netstat 查看端口占用语法格式："),t("code",[v._v("netstat -tunlp | grep 端口号")])]),v._v(" "),t("ul",[t("li",[v._v("-t (tcp) 仅显示tcp相关选项")]),v._v(" "),t("li",[v._v("-u (udp)仅显示udp相关选项")]),v._v(" "),t("li",[v._v("-n 拒绝显示别名，能显示数字的全部转化为数字")]),v._v(" "),t("li",[v._v("-l 仅列出在Listen(监听)的服务状态")]),v._v(" "),t("li",[v._v("-p 显示建立相关链接的程序名")])])])}),[],!1,null,null,null);t.default=s.exports}}]);