---
title: 盛最多水的容器
date: 2021-10-02 10:50:26
permalink: /pages/f08e96/
categories:
  - 算法
  - leetcode
tags:
  - 双指针
---
# 盛最多水的容器

## 题目

给你 `n` 个非负整数 `a1，a2，...，an`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

## 题解

1. 使用首尾指针指向容器两个边，计算初始容量为最大容量。  

2. 每次向中间移动高度小的那个边对应的指针，更新最大容量。

**为什么要移动高度较小的那个边所在的指针呢？**  
因为往内移动的过程中底边变小，只有把高度小的换大一点，才能使容积增大。但是这种思路容易被干扰，比如那是因为都往内移动，底边才变小，那如果左指针往右移动了，把右指针也往右多移动几步呢，边不就大了，这时候容积是大是小呢？
还可以这样想：当前情况下计算的容积，是以较矮的边为基准时，底边最长的时候了，如果把高的一边往内移动，要么会以之前较矮的高度为基准，要么会以更矮的高度为基准，那即使边放大到跟之前一样大，容积不会超过已计算出的最大容量。所以只能把矮的一边往内移动，才有可能计算出更大容量。

**当两边一样高时，又该移动哪个边呢？**  
这时候移动哪边都可以，因为两边之内的容器，底边是变短的，如果想要容积变大，只能靠高度变高，也就是内部要存在两个比当前边大的才行，那么此时移动哪边都可以，最终都会选取到内部更高边的情况。

## 代码

```Java
public int maxArea(int[] height) {
	int l = 0, r=height.length-1;
	int max = 0;
	while (l<r){
		int temp = (r-l)*(Math.min(height[r],height[l]));
		max = Math.max(max,temp);
		if (height[l]<height[r]){
			l++;
		}else {
			r--;
		}
	}
	return max;
}
```


